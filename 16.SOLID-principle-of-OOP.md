# SOLID principle of OOP

- the SOLID principles are five design principles that help developers create software that is easy to maintain, understand, and extend
- applying these principles leads to more robust, scalable, and manageable code, particularly in OOP
- they were introduced by Robert C. Martin (Uncle Bob)
- **SOLID Principles** are:
    - **S** - Single Responsibility Principle (SRP)
    - **O** - Open/Closed Principle
    - **L** - Liskov Substitution Principle
    - **I** - Interface Segregation Principle
    - **D** - Dependency Inversion Principle

## Five Solid Principles:

### 1. Single Responsibility Principle (SRP)

- it’s the most foundational principle
- this principle states that a **class should have one, and only one, reason to change**
- this means a class should be responsible for a single, well-defined piece of functionality
- basically means, class should do one thing only and do it very well
- **Golden Rule:** ***If a class handles more than one purpose, split it***

### 2. Open/Closed Principle

- this principle states that a class should be **open for extension, but closed for modification**
- **Open for extension** = You should be able to add new features/behavior
- **Closed for modification** = You should NOT have to change existing code to do that
- **Golden Rule:** ***Write code that allows new code to be added, not old code to be changed***
- very useful for long term code as it is about expand without damage
- basically means, the class should be coded in such a way that if in future we want to add new features to that object, we simply extend that code rather than editing the whole old code
- Example:
    - Laptop is **closed for modification** — you don’t rip it open every time you want a new feature
    - You just **plug in a new USB device** (mouse, pen drive, printer) — the system **extends** itself

### 3. Liskov Substitution Principle

- if a `class S` is a **subtype** of `class T` , then objects of type `T` should be replaceable with objects of `class S` without altering the correctness of the program
- **subclass must honor the behavior of super class**, subclass should **not throw new exceptions,** **remove functionality** or **break logic** of being extended from super class
- use `interfaces` to define roles clearly, **avoid inheriting behavior** that we don’t need
- **avoid forced inheritance,** especially when a subclass doesn’t fully match the parent
- use `abstract` classes or `interfaces` for contracts, that way we will be able to **define expected behavior correctly**
- **Golden Rule:** ***if a subclass is as superclass, it should must behave as a super class***
- basically this principle says if we are extending any **subclass from a superclass, it should use all the methods of superclass efficiently, without throwing any exceptions or breaking any code logic; OR we should use `interfaces` or `abstracts` to predefine contracts to avoid unnecessary inheritance and follow behavior**

### 4. Interface Segregation Principle

- this principle simply states that **classes should not implement interfaces which they don’t need to use**
- don’t make a class implement more than it actually needs
- ISP matters, because if unnecessary implements are made that ain’t even needed by classes then **our classes get bloated,** **code becomes fragile** - changes break unrelated parts
- **Golden Rule:** ***Favor many small, role-specific interfaces over a large, do-it-all interface***
- a simple question before making interface : **Will every class using this interface use all its methods?  If no, split the interface**
- don’t force classes to implements unused methods; keep interfaces focused and client-specific and split interfaces by behavior/responsibility

### 5. Dependency Inversion Principle (DIP)

- this principle states that, **high-level modules should not depend on low-level modules, Both should depend on abstractions; Abstractions should not depend on details, details should depend on abstractions**
- in simple, high-level logic shouldn’t directly control low-level details; Instead both should depend on an interface - abstraction layer
- with keeping DIP in mind, we can build scalable, testable, and clean architecture
- the principle essentially flips the traditional dependency. Instead of a high-level class directly creating and depending on a low-level, concrete class, both depend on an interface. The high-level class is given an instance of the low-level class that implements that interface, a practice often achieved through **Dependency Injection**.