# 15.2 Polymorphism

- polymorphism means many forms
- In Java, polymorphism allows objects to take many forms based on how methods are defined or overridden
- it’s one of the four main pillars of OOP

## Types of Polymorphism:

### 1. Compile-time Polymorphism (Static Polymorphism)

- this is also known as **method overloading**
- it occurs when a class has **multiple methods with same name, but different parameters** (number of parameters, or type of parameters or both)
- the **compiler determines which method to call first** based on the **method’s signature**
- **Rule:** **Method name must be same** but the **parameters list must be different**

```java
class Calculator {
    // Overloaded method to add two integers
    public int add(int a, int b) {
        return a + b;
    }

    // Overloaded method to add three integers
    public int add(int a, int b, int c) {
        return a + b + c;
    }
}
```

### 2. Runtime Polymorphism (Dynamic Polymorphism)

- this is also known as **method overriding**
- it occurs when a **subclass provides a specific implementation for a method that is already defined in its super class**
- the actual method to be executed is to be **determined at runtime by Java Virtual Machine (JVM)** based on the **object’s type**
- **Rule:** The Method in the subclass must have the **same name, same return type and parameter list** as the method in its super class

```java
class Animal {
    void sound() {
        System.out.println("Animal makes a sound.");
    }
}

class Dog extends Animal {
    @Override
    void sound() {  //method overriding , same method of the superclass 
        System.out.println("Dog barks.");   //method overridden
    }
}
//on calling sound method of Dog Class, "Dog barks." will be printed
```

- the key to run time polymorphism is the ability to use a superclass reference to hold a subclass object, the method call will then execute the overridden method of the subclass

### `@Override`

- this annotation is used to **tell the compiler that a method is intended to override** a method in its superclass or interface
- it’s **not compulsory or required but highly recommended,** because it **code’s readability,** **prevents bugs due to incorrect method signatures** and it **informs the compiler to check if we are actually overriding a method correctly**
- **Syntax:**

```java
@Override
public void methodName() {  //overriding method
    // overriding code here
}
```

## Keys Rules and features:

1. **Inheritance is a must:** Runtime polymorphism can only be achieved through inheritance or interface implementation 
2. A subclass’s method must have same signature of super class’s method while method overriding 
3. Using the `@Override` annotation is a best practice to ensure you're overriding correctly.
4. **The `instanceof` Operator:** Use this operator to check the actual type of an object before casting. This is crucial for avoiding `ClassCastException`s.
5. **Virtual Methods:** By default, all non-static, non-final methods in Java are considered "virtual." This is what allows them to be overridden and resolved at runtime.
6. **Avoid Casting:** While `instanceof` is useful, try to design your code to avoid needing frequent casts. A good polymorphic design often eliminates the need for explicit type checks.
