# 15.4 Abstraction

- concept of abstraction focuses on **showing only essential information to the user and hiding the complex implementation details**
- it simplifies more complex systems by breaking them into smaller, more manageable parts focusing on “what“ object does rather than “how” it does

## Two types of abstraction

### 1. Abstraction using Abstract Classes (partial abstraction)

- an `abstract` class is a **blueprint for other classes** that can contain **both abstract (methods without a body) and concrete (methods with body) methods;** it cannot be instantiated directly
- **To Implement:**
    - declare a class with `abstract` keyword
    - declare any abstract methods with the `abstract` keyword and a semicolon (no method body)
    - subclass that extends the abstract class must provide **implementations for all inherited abstract methods,** or they must also be declared abstract
- **Usage:** its used when we have a common base for related classes, and we want to provide some default implementation while forcing subclasses to implement specific behaviors; it represents **“is-a”** relationship
- **Rules:**
    - Objects cannot be created from abstract class
    - can have constructors but even they will be called by subclass
    - it can have final methods and static methods

```java
// Abstract Class
public abstract class Vehicle {
    public abstract void drive(); // Abstract method: no implementation here

    public void startEngine() { // Concrete method: implementation here
        System.out.println("Engine started.");
    }
}

// Concrete Subclass
public class Car extends Vehicle {
    @Override
    public void drive() { // Must implement abstract method
        System.out.println("Car is driving.");
    }
}

// Usage
// Vehicle myVehicle = new Vehicle(); // Error: Cannot instantiate abstract class
Vehicle myCar = new Car(); // OK
myCar.startEngine(); // Output: Engine started.
myCar.drive();      // Output: Car is driving.
```

### 2. Abstraction using Interface (100% abstraction)

- an `interface` is a blueprint that **defines a contract: a set of methods that a class must implement**
- **To Implement:**
    - declare the Interface with the `interface` keyword
    - declare methods (abstract, default or static)
    - classes that **implement the interface must provide implementation for all inherited abstract methods** of Interface
- **Usage:** it’s used when we want to **define a common behavior across unrelated classes,** or to achieve multiple inheritances of behavior (a class can implement multiple interfaces); it represents a **“can-do”** or **“has-a”** capability
- **Rules:**
    - cannot create objects of an Interface
    - variables are implicitly `public` , `static` , `final`
    - methods without body are implicitly `public abstract`
    - can **extend multiple interfaces**

```java
// Interface
public interface Drivable {
    void drive(); // Abstract method (implicitly public abstract)

    default void brake() { // Default method (implementation provided)
        System.out.println("Applying brakes.");
    }
}

// Class implementing the interface
public class Truck implements Drivable {
    @Override
    public void drive() { // Must implement abstract method
        System.out.println("Truck is driving slowly.");
    }
}

// Usage
// Drivable myDrivable = new Drivable(); // Error: Cannot instantiate interface
Drivable myTruck = new Truck();
myTruck.drive(); // Output: Truck is driving slowly.
myTruck.brake(); // Output: Applying brakes.
```