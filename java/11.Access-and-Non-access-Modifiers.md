# Access and Non-access Modifiers

# Access Modifiers

- access modifiers in java are keywords that set the accessibility (visibility) of class, constructors, variables or methods
- they control what other classes can access a member

## Four types of access modifiers:

### 1. `public`

- these members are **accessible from anywhere in the program**
- **least restrictive modifier**
- **Rule:** the member is visible to all classes in all packages
- **Where to Use:** For methods and fields that are a part of a class’s public API

```java
public class PublicExample {
    public int publicVariable = 10;
    public void publicMethod() { /* ... */ }
}
```

### 2. `protected`

- these members are **accessible within the same package and by subclass in other packages**
- **Rule:** visible to all classes in the same package and to any subclass, even if the subclass is in a different package
- **Where to Use:** For members that are intended for the class itself and its descendants. This is common when building  a class hierarchy where parent class needs to share resource with its children

```java
public class ProtectedExample {
    protected int protectedVariable = 20;
}
```

### 3. `default`  (Package-Private)

- if we don’t specify any access modifier, the **member has default access.** This means its **accessible only within the same package**
- **Rule:** visible to all other classes within the same package, but not to classes in other packages
- **Where to Use:** when we want to restrict access to a group of related classes that are logically grouped together in a package. It’s often used for utility or helper classes

```java
// Default access (no keyword)
class DefaultExample {
    String defaultVariable = "Hello";
}
```

### 4. `private`

- these **members are accessible only within the same class**
- **most restrictive modifier**
- **Rule:** the member is not visible to any other class, even subclass within the same package
- **Where to Use:** To enforce encapsulation, private members hide an object’s internal state, and access is typically provided through public getter and setter methods

```java
public class PrivateExample {
    private int privateVariable = 30;
    private void privateMethod() { /* ... */ }
}
```

# Non-access Modifiers

- non-access modifiers in java are keywords that **define the behavior** of a class, method or variable, rather than its visibility
- core part of OOP as they enforce rules for inheritance, state and concurrency

## Seven types of non-access modifiers:

### 1. `final`

- it makes an entity **immutable**
- Usage: to make a constant, to prevent a method from being overridden, or to prevent a class from being inherited. This enforces stability and security
- **Rules:**
    - `final` variables must be initialized once
    - `final` methods cannot be overridden
    - `final` classes cannot be extended

```java
public final class ImmutablePoint {
    private final int x; // Final instance variable
    public ImmutablePoint(int x) {
        this.x = x;
    }
}
```

### 2. `static`

- it makes a **member belong to itself,** not to any specific object
- it’s **shared by all instances**
- **Usage:** To create class-level variables or methods. This is for utilities or shared data that don’t depend on an object’s state
- **Rules:**
    - static members are accessed via class name (e.g., `Math.PI`)
    - static members can only access other static members
    - cannot be applied to local variables

```java
public class Counter {
    public static int count = 0; // Shared by all objects
    public Counter() {
        count++;
    }
}
```

### 3. `abstract`

- it indicates that a **method or class is incomplete and must be implemented by subclass**
- **Usage:** To define a **common blueprint for a set of related classes.** It enforces a contract that subclass must follow
- **Rules:**
    - abstract class cannot be instantiated
    - abstract method has no body and always be must in an abstract class
    - a concrete subclass must provide an implementation for all abstract methods

```java
public abstract class Shape {
    public abstract double getArea(); // No method body
}
```

### 4. `transient`

- used for **serialization**
- it marks an instance variable to be excluded when an object is serialized (converted into byte stream)
- **Usage:** To protect sensitive data (like passwords) or data that cannot be serialized from being written to a file or sent over a network
- **Rules:**
    - can only be applied to non-static instance variables
    - the variable’s value will be reset to its default when the object is deserialized

```java
import java.io.Serializable;
public class User implements Serializable {
    private String username;
    private transient String password; // Will not be serialized
}
```

### 5. `volatile`

- it ensures that a **variable’s value is always read from and written to main memory**
- its primary used in **multithreaded programming**
- **Usage:** To guarantee that changes to a variable by one thread are immediately visible to all other threads
- **Rules:**
    - can only be applied to instance variables
    - does not guarantee atomicity for operations like `count++`

```java
public class ThreadSafeCounter {
    private volatile boolean stop = false;
    public void run() {
        while (!stop) { /* ... */ }
    }
    public void stopThread() {
        stop = true; // The change is visible to all threads
    }
}
```

### 6. `synchronized`

- it is a **multithreading keyword** that provides a **lock on a method or code block**
- **Usage:** To **prevent multiple threads from executing the same block of code simultaneously.** This prevents race conditions and data corruption
- **Rules:**
    - can be applied to methods or code blocks
    - ensures exclusive access to the shared resource
    - a method lock is on the object instance (or the Class object for static methods)

```java
public class SynchronizedCounter {
    private int count = 0;
    public synchronized void increment() {
        count++; // Only one thread can be here at a time
    }
}
```

### 7. `native`

- this keyword indicates that a **method’s implementation is written in a programming language other than Java, typically C or C++,** these methods are located in external, dynamically linked library
- **Usage:** It’s used **when a task requires direct hardware access,** is performance-critical, or needs to use an existing library written in another language
- **Rules:**
    - a native method has no body in the Java code; it’s declaration followed by a semicolon
    - the native keyword is the foundation of the JNI, which allows java code to interact with platform-specific code and hardware

```java
public class MyNative {
    // Declares a native method with no body.
    public native void sayHello();

    public static void main(String[] args) {
        // Assume sayHello is implemented in a separate C library.
        new MyNative().sayHello();
    }
}
```